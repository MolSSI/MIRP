<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MolSSI Integral Reference Project: mirp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="mirp_logo_477x219.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MolSSI Integral Reference Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mirp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of data for testing the Boys function.  <a href="structmirp_1_1boys__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1boys__data__entry.html">boys_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An single entry for a Boys function test.  <a href="structmirp_1_1boys__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps with calling callbacks with the given number of centers.  <a href="structmirp_1_1callback__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1callback__helper_3_014_01_4.html">callback_helper&lt; 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shell of cartesian gaussian functions (double precision)  <a href="structmirp_1_1gaussian__shell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__shell__str.html">gaussian_shell_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shell of cartesian gaussian functions (strings)  <a href="structmirp_1_1gaussian__shell__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__single__str.html">gaussian_single_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single cartesian gaussian function.  <a href="structmirp_1_1gaussian__single__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of a data file for contracted integrals.  <a href="structmirp_1_1integral__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for a single contracted integral.  <a href="structmirp_1_1integral__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of a data file for a single cartesian integral.  <a href="structmirp_1_1integral__single__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__single__data__entry.html">integral_single_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for a single cartesian integral.  <a href="structmirp_1_1integral__single__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada07f7317a5c464516b637ff2ea73581"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ada07f7317a5c464516b637ff2ea73581">cmdline_has_arg</a> (const std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:ada07f7317a5c464516b637ff2ea73581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the given command line has an argument.  <a href="#ada07f7317a5c464516b637ff2ea73581">More...</a><br /></td></tr>
<tr class="separator:ada07f7317a5c464516b637ff2ea73581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1667b1a3866f9d460c474251c1bf471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a1667b1a3866f9d460c474251c1bf471f">cmdline_get_switch</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a1667b1a3866f9d460c474251c1bf471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the command line has a switch.  <a href="#a1667b1a3866f9d460c474251c1bf471f">More...</a><br /></td></tr>
<tr class="separator:a1667b1a3866f9d460c474251c1bf471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958486b749ea0de3331bbc2256574343"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a958486b749ea0de3331bbc2256574343">cmdline_get_arg_str</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a958486b749ea0de3331bbc2256574343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a string.  <a href="#a958486b749ea0de3331bbc2256574343">More...</a><br /></td></tr>
<tr class="separator:a958486b749ea0de3331bbc2256574343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c68eccff37c596fcd49b3a234649e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ad8c68eccff37c596fcd49b3a234649e6">cmdline_get_arg_str</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg, const std::string &amp;def)</td></tr>
<tr class="memdesc:ad8c68eccff37c596fcd49b3a234649e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a string, with a default.  <a href="#ad8c68eccff37c596fcd49b3a234649e6">More...</a><br /></td></tr>
<tr class="separator:ad8c68eccff37c596fcd49b3a234649e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c5d6bc1620517cb1dd3038139b222e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a14c5d6bc1620517cb1dd3038139b222e">cmdline_get_arg_long</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a14c5d6bc1620517cb1dd3038139b222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a long integer.  <a href="#a14c5d6bc1620517cb1dd3038139b222e">More...</a><br /></td></tr>
<tr class="separator:a14c5d6bc1620517cb1dd3038139b222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a5339c262fa33a0e966f09c39d9e3c7b8">cmdline_get_arg_long</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg, long def)</td></tr>
<tr class="memdesc:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a long integer, with a default.  <a href="#a5339c262fa33a0e966f09c39d9e3c7b8">More...</a><br /></td></tr>
<tr class="separator:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a5d1e9d32611a0f001ff3af9cf821ec33">convert_cmdline</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the command line passed to a program into a vector of strings.  <a href="#a5d1e9d32611a0f001ff3af9cf821ec33">More...</a><br /></td></tr>
<tr class="separator:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdae67e044b4ee1c9b7a02614b093354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#acdae67e044b4ee1c9b7a02614b093354">read_construct_basis</a> (const std::string &amp;xyzfile, const std::string &amp;basfile)</td></tr>
<tr class="memdesc:acdae67e044b4ee1c9b7a02614b093354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a basis from an XYZ file and a basis set file.  <a href="#acdae67e044b4ee1c9b7a02614b093354">More...</a><br /></td></tr>
<tr class="separator:acdae67e044b4ee1c9b7a02614b093354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8bdb46ad41b7f20f067871bd064520"><td class="memTemplParams" colspan="2">template&lt;int N, typename Func &gt; </td></tr>
<tr class="memitem:a0d8bdb46ad41b7f20f067871bd064520"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a0d8bdb46ad41b7f20f067871bd064520">integral_test_reference</a> (const std::string &amp;ref_filepath, Func cb)</td></tr>
<tr class="memdesc:a0d8bdb46ad41b7f20f067871bd064520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests a reference file for consistency.  <a href="#a0d8bdb46ad41b7f20f067871bd064520">More...</a><br /></td></tr>
<tr class="separator:a0d8bdb46ad41b7f20f067871bd064520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d45a24f2eb91eb68273778e8139bbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a7d45a24f2eb91eb68273778e8139bbfa">integral4_create_reference</a> (const std::string &amp;xyz_filepath, const std::string &amp;basis_filepath, const std::string &amp;output_filepath, const std::string &amp;header, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;amlist, <a class="el" href="typedefs_8h.html#a961666448f7e097fb4bd399d493c97f0">cb_integral4_exact</a> cb)</td></tr>
<tr class="memdesc:a7d45a24f2eb91eb68273778e8139bbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a file with exact double reference values of contracted integrals.  <a href="#a7d45a24f2eb91eb68273778e8139bbfa">More...</a><br /></td></tr>
<tr class="separator:a7d45a24f2eb91eb68273778e8139bbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1bbf17ac462d26290f4fe81679767e"><td class="memItemLeft" align="right" valign="top">template long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a3c1bbf17ac462d26290f4fe81679767e">integral_test_reference&lt; 4, cb_integral4_exact &gt;</a> (const std::string &amp;, <a class="el" href="typedefs_8h.html#a961666448f7e097fb4bd399d493c97f0">cb_integral4_exact</a>)</td></tr>
<tr class="separator:a3c1bbf17ac462d26290f4fe81679767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08924503706850419e98bf66456e4b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#af08924503706850419e98bf66456e4b0">read_hexdouble</a> (std::istream &amp;fs)</td></tr>
<tr class="memdesc:af08924503706850419e98bf66456e4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double precision number from an ASCII file.  <a href="#af08924503706850419e98bf66456e4b0">More...</a><br /></td></tr>
<tr class="separator:af08924503706850419e98bf66456e4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05562936e5f14fff46fa179684b71fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a05562936e5f14fff46fa179684b71fdd">write_hexdouble</a> (double d, std::ostream &amp;fs)</td></tr>
<tr class="memdesc:a05562936e5f14fff46fa179684b71fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a double precision number as a hexfloat to an ASCII file.  <a href="#a05562936e5f14fff46fa179684b71fdd">More...</a><br /></td></tr>
<tr class="separator:a05562936e5f14fff46fa179684b71fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567695318a1326281c228be5413808e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a567695318a1326281c228be5413808e8">reffile_write_basis</a> (const std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; &amp;shells, std::ostream &amp;fs)</td></tr>
<tr class="memdesc:a567695318a1326281c228be5413808e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write basis information to a file.  <a href="#a567695318a1326281c228be5413808e8">More...</a><br /></td></tr>
<tr class="separator:a567695318a1326281c228be5413808e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d752a48c62a30d4f85481447e1f26c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa0d752a48c62a30d4f85481447e1f26c">reffile_read_basis</a> (std::istream &amp;fs)</td></tr>
<tr class="memdesc:aa0d752a48c62a30d4f85481447e1f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads basis information from a reference file.  <a href="#aa0d752a48c62a30d4f85481447e1f26c">More...</a><br /></td></tr>
<tr class="separator:aa0d752a48c62a30d4f85481447e1f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68880a28986479f968df96e21e54f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#af68880a28986479f968df96e21e54f05">boys_max_m</a> (const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;data)</td></tr>
<tr class="memdesc:af68880a28986479f968df96e21e54f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum value of <code>m</code> in a Boys test data structure.  <a href="#af68880a28986479f968df96e21e54f05">More...</a><br /></td></tr>
<tr class="separator:af68880a28986479f968df96e21e54f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab311bddb0cf68d4424b2ee430d817b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a2ab311bddb0cf68d4424b2ee430d817b">boys_read_file</a> (const std::string &amp;filepath, bool is_input)</td></tr>
<tr class="memdesc:a2ab311bddb0cf68d4424b2ee430d817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file with reference data for the Boys function.  <a href="#a2ab311bddb0cf68d4424b2ee430d817b">More...</a><br /></td></tr>
<tr class="separator:a2ab311bddb0cf68d4424b2ee430d817b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bc3e121f04df0e0a21551194ae3cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a24bc3e121f04df0e0a21551194ae3cb8">boys_write_file</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;data)</td></tr>
<tr class="memdesc:a24bc3e121f04df0e0a21551194ae3cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a file with reference data for the Boys function.  <a href="#a24bc3e121f04df0e0a21551194ae3cb8">More...</a><br /></td></tr>
<tr class="separator:a24bc3e121f04df0e0a21551194ae3cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541924126eaa8e44e802e756361f9747"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a541924126eaa8e44e802e756361f9747">boys_verify_test_main</a> (const std::string &amp;filepath, const std::string &amp;floattype, int extra_m, slong working_prec)</td></tr>
<tr class="memdesc:a541924126eaa8e44e802e756361f9747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a test of the Boys function.  <a href="#a541924126eaa8e44e802e756361f9747">More...</a><br /></td></tr>
<tr class="separator:a541924126eaa8e44e802e756361f9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#afe4f94b598ebbd2f92a358bdbfbc3361">boys_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header)</td></tr>
<tr class="memdesc:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a test file for the Boys function from a given input file.  <a href="#afe4f94b598ebbd2f92a358bdbfbc3361">More...</a><br /></td></tr>
<tr class="separator:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a668b0bb583e336bbf6c87736435e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a201a668b0bb583e336bbf6c87736435e">print_results</a> (unsigned long nfailed, unsigned long ntests)</td></tr>
<tr class="memdesc:a201a668b0bb583e336bbf6c87736435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the results of a test.  <a href="#a201a668b0bb583e336bbf6c87736435e">More...</a><br /></td></tr>
<tr class="separator:a201a668b0bb583e336bbf6c87736435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c928248b24b1578f893e0680abaaab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a04c928248b24b1578f893e0680abaaab">amchar_to_int</a> (char am)</td></tr>
<tr class="memdesc:a04c928248b24b1578f893e0680abaaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character representing an angular momentum to an integer.  <a href="#a04c928248b24b1578f893e0680abaaab">More...</a><br /></td></tr>
<tr class="separator:a04c928248b24b1578f893e0680abaaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49d727a23ba27fe18fc59b1a1af81f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#acf49d727a23ba27fe18fc59b1a1af81f">element_to_z</a> (const std::string &amp;element)</td></tr>
<tr class="memdesc:acf49d727a23ba27fe18fc59b1a1af81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representing an element to its atomic Z number.  <a href="#acf49d727a23ba27fe18fc59b1a1af81f">More...</a><br /></td></tr>
<tr class="separator:acf49d727a23ba27fe18fc59b1a1af81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e024610a0f24170e0c7dfde2bfd195c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a8e024610a0f24170e0c7dfde2bfd195c">str_tolower</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8e024610a0f24170e0c7dfde2bfd195c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to lower case, returning a copy.  <a href="#a8e024610a0f24170e0c7dfde2bfd195c">More...</a><br /></td></tr>
<tr class="separator:a8e024610a0f24170e0c7dfde2bfd195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa167f623301da5e48af3af24931eb1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#abfa167f623301da5e48af3af24931eb1">trim</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abfa167f623301da5e48af3af24931eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims spaces and tabs from both ends of a string, returning a copy.  <a href="#abfa167f623301da5e48af3af24931eb1">More...</a><br /></td></tr>
<tr class="separator:abfa167f623301da5e48af3af24931eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac8b5ea8d0bc6fa4f54709a20c5660218">split</a> (const std::string &amp;s, char sep=' ')</td></tr>
<tr class="memdesc:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into components.  <a href="#ac8b5ea8d0bc6fa4f54709a20c5660218">More...</a><br /></td></tr>
<tr class="separator:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74abfb9a562297e55fb9e47a01e72ec0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a74abfb9a562297e55fb9e47a01e72ec0">file_skip</a> (std::istream &amp;fs, char commentchar)</td></tr>
<tr class="memdesc:a74abfb9a562297e55fb9e47a01e72ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the stream past any comment and blank lines.  <a href="#a74abfb9a562297e55fb9e47a01e72ec0">More...</a><br /></td></tr>
<tr class="separator:a74abfb9a562297e55fb9e47a01e72ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac7ec7b283a1a72f007fdc0b0ded9377b">nintegrals</a> (const <a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a> &amp;ent)</td></tr>
<tr class="memdesc:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of integrals computed in an entry.  <a href="#ac7ec7b283a1a72f007fdc0b0ded9377b">More...</a><br /></td></tr>
<tr class="separator:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d48387ad435d637ae6ec404372c449"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a68d48387ad435d637ae6ec404372c449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a68d48387ad435d637ae6ec404372c449">integral_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_str_type cb)</td></tr>
<tr class="memdesc:a68d48387ad435d637ae6ec404372c449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test of contracted integrals.  <a href="#a68d48387ad435d637ae6ec404372c449">More...</a><br /></td></tr>
<tr class="separator:a68d48387ad435d637ae6ec404372c449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f3b05c41e5f1c10cc383b336c20c8b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a72f3b05c41e5f1c10cc383b336c20c8b"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a72f3b05c41e5f1c10cc383b336c20c8b">integral_verify_test</a> (const std::string &amp;filepath, slong working_prec, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_str_type cb)</td></tr>
<tr class="memdesc:a72f3b05c41e5f1c10cc383b336c20c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a test of single cartesian integrals.  <a href="#a72f3b05c41e5f1c10cc383b336c20c8b">More...</a><br /></td></tr>
<tr class="separator:a72f3b05c41e5f1c10cc383b336c20c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8084713e84c8e42f57ad70e9f90382"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ade8084713e84c8e42f57ad70e9f90382"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ade8084713e84c8e42f57ad70e9f90382">integral_verify_test_exact</a> (const std::string &amp;filepath, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_exact_type cb, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_type cb_arb)</td></tr>
<tr class="memdesc:ade8084713e84c8e42f57ad70e9f90382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test contracted integrals in exact double precision.  <a href="#ade8084713e84c8e42f57ad70e9f90382">More...</a><br /></td></tr>
<tr class="separator:ade8084713e84c8e42f57ad70e9f90382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad397fea269958039a7e7069008bcc7f7"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ad397fea269958039a7e7069008bcc7f7">integral_create_test&lt; 4 &gt;</a> (const std::string &amp;, const std::string &amp;, slong, long, const std::string &amp;, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_str_type)</td></tr>
<tr class="separator:ad397fea269958039a7e7069008bcc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd07901b6956b9961a8fe71fb7361a5"><td class="memItemLeft" align="right" valign="top">template long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#abdd07901b6956b9961a8fe71fb7361a5">integral_verify_test&lt; 4 &gt;</a> (const std::string &amp;, slong, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_str_type)</td></tr>
<tr class="separator:abdd07901b6956b9961a8fe71fb7361a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8dfc46870c2a1ed84dc516fe2de727"><td class="memItemLeft" align="right" valign="top">template long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aff8dfc46870c2a1ed84dc516fe2de727">integral_verify_test_exact&lt; 4 &gt;</a> (const std::string &amp;, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_exact_type, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_type)</td></tr>
<tr class="separator:aff8dfc46870c2a1ed84dc516fe2de727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8f8cf985f47c8ab49c5eedf92e27f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a64d8f8cf985f47c8ab49c5eedf92e27f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a64d8f8cf985f47c8ab49c5eedf92e27f">integral_single_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_str_type cb)</td></tr>
<tr class="memdesc:a64d8f8cf985f47c8ab49c5eedf92e27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test of single cartesian integrals.  <a href="#a64d8f8cf985f47c8ab49c5eedf92e27f">More...</a><br /></td></tr>
<tr class="separator:a64d8f8cf985f47c8ab49c5eedf92e27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37a4b679edeb6c9f01e3a3cf2fe2249"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa37a4b679edeb6c9f01e3a3cf2fe2249">integral_single_create_test&lt; 4 &gt;</a> (const std::string &amp;, const std::string &amp;, slong, long, const std::string &amp;, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_str_type)</td></tr>
<tr class="separator:aa37a4b679edeb6c9f01e3a3cf2fe2249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8587e92b0a4446137f5065b49f33fc"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a9e8587e92b0a4446137f5065b49f33fc"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a9e8587e92b0a4446137f5065b49f33fc">integral_single_verify_test</a> (const std::string &amp;filepath, slong working_prec, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_str_type cb)</td></tr>
<tr class="memdesc:a9e8587e92b0a4446137f5065b49f33fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a test of single cartesian integrals using interval math.  <a href="#a9e8587e92b0a4446137f5065b49f33fc">More...</a><br /></td></tr>
<tr class="separator:a9e8587e92b0a4446137f5065b49f33fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e112c63a42a21d9175a12747116b297"><td class="memItemLeft" align="right" valign="top">template long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a6e112c63a42a21d9175a12747116b297">integral_single_verify_test&lt; 4 &gt;</a> (const std::string &amp;, slong, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_str_type)</td></tr>
<tr class="separator:a6e112c63a42a21d9175a12747116b297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e47ecf511580a67d7844dc23a011bd"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a57e47ecf511580a67d7844dc23a011bd"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a57e47ecf511580a67d7844dc23a011bd">integral_single_verify_test_exact</a> (const std::string &amp;filepath, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_exact_type cb, typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_type cb_arb)</td></tr>
<tr class="memdesc:a57e47ecf511580a67d7844dc23a011bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test single cartesian integrals in exact double precision.  <a href="#a57e47ecf511580a67d7844dc23a011bd">More...</a><br /></td></tr>
<tr class="separator:a57e47ecf511580a67d7844dc23a011bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2305aba9668200a844f3eeb8e4f36744"><td class="memItemLeft" align="right" valign="top">template long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a2305aba9668200a844f3eeb8e4f36744">integral_single_verify_test_exact&lt; 4 &gt;</a> (const std::string &amp;, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_exact_type, <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_type)</td></tr>
<tr class="separator:a2305aba9668200a844f3eeb8e4f36744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac9cfb997ce9f6b9062606aa5fb1bc440">testfile_read_integral_single</a> (const std::string &amp;filepath, int n, bool is_input)</td></tr>
<tr class="memdesc:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read generic single integral test data from a file.  <a href="#ac9cfb997ce9f6b9062606aa5fb1bc440">More...</a><br /></td></tr>
<tr class="separator:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1968d0c11645895c1a3c03a47691db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa1968d0c11645895c1a3c03a47691db0">testfile_write_integral_single</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> &amp;data)</td></tr>
<tr class="memdesc:aa1968d0c11645895c1a3c03a47691db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write generic single integral test data to a file.  <a href="#aa1968d0c11645895c1a3c03a47691db0">More...</a><br /></td></tr>
<tr class="separator:aa1968d0c11645895c1a3c03a47691db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a0593df7c82e1f3e922aebfca8f2ac44b">testfile_read_integral</a> (const std::string &amp;filepath, int n, bool is_input)</td></tr>
<tr class="memdesc:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read generic contracted integral test data from a file.  <a href="#a0593df7c82e1f3e922aebfca8f2ac44b">More...</a><br /></td></tr>
<tr class="separator:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac5a6837ba61cdeb32f0fd40a61b2b351">testfile_write_integral</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1integral__data.html">integral_data</a> &amp;data)</td></tr>
<tr class="memdesc:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write generic contracted integral test data to a file.  <a href="#ac5a6837ba61cdeb32f0fd40a61b2b351">More...</a><br /></td></tr>
<tr class="separator:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a33de878bfad803d7a1d02be008e1df75"><td class="memItemLeft" align="right" valign="top">static const std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a33de878bfad803d7a1d02be008e1df75">max_length</a> = std::numeric_limits&lt;std::streamsize&gt;::max()</td></tr>
<tr class="memdesc:a33de878bfad803d7a1d02be008e1df75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a line.  <a href="#a33de878bfad803d7a1d02be008e1df75">More...</a><br /></td></tr>
<tr class="separator:a33de878bfad803d7a1d02be008e1df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace for MIRP in C++ </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a04c928248b24b1578f893e0680abaaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c928248b24b1578f893e0680abaaab">&#9670;&nbsp;</a></span>amchar_to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::amchar_to_int </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>am</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a character representing an angular momentum to an integer. </p>
<p>Converts s,p,d,f,... to 0,1,2,3,...</p>
<p>The character is case insensitive</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the character cannot be converted to an integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe4f94b598ebbd2f92a358bdbfbc3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4f94b598ebbd2f92a358bdbfbc3361">&#9670;&nbsp;</a></span>boys_create_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::boys_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a test file for the Boys function from a given input file. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>Path to the input file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>File to write the computed data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of decimal digits to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Any descriptive header data (will be appended to the existing header in the input file) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af68880a28986479f968df96e21e54f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68880a28986479f968df96e21e54f05">&#9670;&nbsp;</a></span>boys_max_m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::boys_max_m </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum value of <code>m</code> in a Boys test data structure. </p>

</div>
</div>
<a id="a2ab311bddb0cf68d4424b2ee430d817b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab311bddb0cf68d4424b2ee430d817b">&#9670;&nbsp;</a></span>boys_read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a> mirp::boys_read_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a file with reference data for the Boys function. </p>
<p>This reads in <code>m</code> and <code>t</code> entries for the Boys function, as well as a descriptive header.</p>
<p>If <code>is_input</code> is true, then then <code>ndigits</code> and the reference entries are also read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file does not exist or there there is a problem reading/parsing the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>Set to true when reading an input file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the file </dd></dl>

</div>
</div>
<a id="a541924126eaa8e44e802e756361f9747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541924126eaa8e44e802e756361f9747">&#9670;&nbsp;</a></span>boys_verify_test_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::boys_verify_test_main </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>floattype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a test of the Boys function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floattype</td><td>Type of floating point to test ("double", for example) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra_m</td><td>Additional <code>m</code> entries (used to test recurrence relations) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of tests that have failed </dd></dl>

</div>
</div>
<a id="a24bc3e121f04df0e0a21551194ae3cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bc3e121f04df0e0a21551194ae3cb8">&#9670;&nbsp;</a></span>boys_write_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::boys_write_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a file with reference data for the Boys function. </p>
<p>This writes reference data files only. It can not be used to write input files.</p>
<p>Any existing file will be overrwitten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c5d6bc1620517cb1dd3038139b222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c5d6bc1620517cb1dd3038139b222e">&#9670;&nbsp;</a></span>cmdline_get_arg_long() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::cmdline_get_arg_long </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a long integer. </p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the argument key or the value is not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line </dd></dl>

</div>
</div>
<a id="a5339c262fa33a0e966f09c39d9e3c7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5339c262fa33a0e966f09c39d9e3c7b8">&#9670;&nbsp;</a></span>cmdline_get_arg_long() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::cmdline_get_arg_long </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a long integer, with a default. </p>
<p>If the argument key is not given on the command line, the default parameter <code>def</code> is returned instead.</p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>A default value of the argument to use if <code>arg</code> is not given on the command line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line, or the value of <code>def</code> </dd></dl>

</div>
</div>
<a id="a958486b749ea0de3331bbc2256574343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958486b749ea0de3331bbc2256574343">&#9670;&nbsp;</a></span>cmdline_get_arg_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::cmdline_get_arg_str </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a string. </p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the argument key or the value is not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line </dd></dl>

</div>
</div>
<a id="ad8c68eccff37c596fcd49b3a234649e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c68eccff37c596fcd49b3a234649e6">&#9670;&nbsp;</a></span>cmdline_get_arg_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::cmdline_get_arg_str </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a string, with a default. </p>
<p>If the argument key is not given on the command line, the default parameter <code>def</code> is returned instead.</p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>A default value of the argument to use if <code>arg</code> is not given on the command line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line, or the value of <code>def</code> </dd></dl>

</div>
</div>
<a id="a1667b1a3866f9d460c474251c1bf471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1667b1a3866f9d460c474251c1bf471f">&#9670;&nbsp;</a></span>cmdline_get_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::cmdline_get_switch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the command line has a switch. </p>
<dl class="section note"><dt>Note</dt><dd>After seeing if the switch exists, it is removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to check (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>cmdline</code> contains the switch, false otherwise </dd></dl>

</div>
</div>
<a id="ada07f7317a5c464516b637ff2ea73581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada07f7317a5c464516b637ff2ea73581">&#9670;&nbsp;</a></span>cmdline_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::cmdline_has_arg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the given command line has an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to check (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>cmdline</code> contains the argument, false otherwise </dd></dl>

</div>
</div>
<a id="a5d1e9d32611a0f001ff3af9cf821ec33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e9d32611a0f001ff3af9cf821ec33">&#9670;&nbsp;</a></span>convert_cmdline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mirp::convert_cmdline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the command line passed to a program into a vector of strings. </p>
<p>After conversion, the command line is able to be used in the other <code>cmdline_</code> functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command line arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The command line arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The command line, split into a vector of strings and lightly processed. </dd></dl>

</div>
</div>
<a id="acf49d727a23ba27fe18fc59b1a1af81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49d727a23ba27fe18fc59b1a1af81f">&#9670;&nbsp;</a></span>element_to_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::element_to_z </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string representing an element to its atomic Z number. </p>
<p>Converts H to 1, He to 2, etc</p>
<p>The element string is case insensitive</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the character cannot be converted to an integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74abfb9a562297e55fb9e47a01e72ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74abfb9a562297e55fb9e47a01e72ec0">&#9670;&nbsp;</a></span>file_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::file_skip </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>commentchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the stream past any comment and blank lines. </p>
<p>The stream will be advanced past the lines that were read.</p>
<p>If an EOF is encountered, false is returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>The stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commentchar</td><td>Lines beginning with the character will be skipped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is additional data in the file, false on EOF </dd></dl>

</div>
</div>
<a id="a7d45a24f2eb91eb68273778e8139bbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d45a24f2eb91eb68273778e8139bbfa">&#9670;&nbsp;</a></span>integral4_create_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral4_create_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xyz_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>basis_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>amlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a961666448f7e097fb4bd399d493c97f0">cb_integral4_exact</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a file with exact double reference values of contracted integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is being left un-templatized due to the handling of permutational symmetry</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz_filepath</td><td>Path to the XYZ file containing the molecule to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis_filepath</td><td>Path to a basis set file to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amlist</td><td>Vector of AM classes to compute. If empty, all will be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals to exact double precision </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d48387ad435d637ae6ec404372c449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d48387ad435d637ae6ec404372c449">&#9670;&nbsp;</a></span>integral_create_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_str_type&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test of contracted integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>The input file to use for integral parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of digits to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad397fea269958039a7e7069008bcc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad397fea269958039a7e7069008bcc7f7">&#9670;&nbsp;</a></span>integral_create_test< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemirp.html#a68d48387ad435d637ae6ec404372c449">mirp::integral_create_test</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_str_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d8f8cf985f47c8ab49c5eedf92e27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d8f8cf985f47c8ab49c5eedf92e27f">&#9670;&nbsp;</a></span>integral_single_create_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral_single_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_str_type&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test of single cartesian integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>The input file to use for integral parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of digits to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa37a4b679edeb6c9f01e3a3cf2fe2249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37a4b679edeb6c9f01e3a3cf2fe2249">&#9670;&nbsp;</a></span>integral_single_create_test< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemirp.html#a64d8f8cf985f47c8ab49c5eedf92e27f">mirp::integral_single_create_test</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_str_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e8587e92b0a4446137f5065b49f33fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8587e92b0a4446137f5065b49f33fc">&#9670;&nbsp;</a></span>integral_single_verify_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral_single_verify_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_str_type&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a test of single cartesian integrals using interval math. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="a6e112c63a42a21d9175a12747116b297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e112c63a42a21d9175a12747116b297">&#9670;&nbsp;</a></span>integral_single_verify_test< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template long <a class="el" href="namespacemirp.html#a9e8587e92b0a4446137f5065b49f33fc">mirp::integral_single_verify_test</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_str_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57e47ecf511580a67d7844dc23a011bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e47ecf511580a67d7844dc23a011bd">&#9670;&nbsp;</a></span>integral_single_verify_test_exact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral_single_verify_test_exact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_exact_type&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_single_type&#160;</td>
          <td class="paramname"><em>cb_arb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test single cartesian integrals in exact double precision. </p>
<p>The integrals are tested to be exactly equal to the reference data or to integral computed with very large accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals in exact double precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arb</td><td>Function that computes single cartesian integrals using interval arithmetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="a2305aba9668200a844f3eeb8e4f36744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2305aba9668200a844f3eeb8e4f36744">&#9670;&nbsp;</a></span>integral_single_verify_test_exact< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template long <a class="el" href="namespacemirp.html#a57e47ecf511580a67d7844dc23a011bd">mirp::integral_single_verify_test_exact</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_exact_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_single_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d8bdb46ad41b7f20f067871bd064520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8bdb46ad41b7f20f067871bd064520">&#9670;&nbsp;</a></span>integral_test_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral_test_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ref_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests a reference file for consistency. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_filepath</td><td>Path to the reference file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals to exact double precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="a3c1bbf17ac462d26290f4fe81679767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1bbf17ac462d26290f4fe81679767e">&#9670;&nbsp;</a></span>integral_test_reference< 4, cb_integral4_exact >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template long <a class="el" href="namespacemirp.html#a0d8bdb46ad41b7f20f067871bd064520">mirp::integral_test_reference</a>&lt; 4, <a class="el" href="typedefs_8h.html#a961666448f7e097fb4bd399d493c97f0">cb_integral4_exact</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a961666448f7e097fb4bd399d493c97f0">cb_integral4_exact</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72f3b05c41e5f1c10cc383b336c20c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f3b05c41e5f1c10cc383b336c20c8b">&#9670;&nbsp;</a></span>integral_verify_test()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral_verify_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_str_type&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a test of single cartesian integrals. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="abdd07901b6956b9961a8fe71fb7361a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd07901b6956b9961a8fe71fb7361a5">&#9670;&nbsp;</a></span>integral_verify_test< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template long <a class="el" href="namespacemirp.html#a72f3b05c41e5f1c10cc383b336c20c8b">mirp::integral_verify_test</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_str_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade8084713e84c8e42f57ad70e9f90382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8084713e84c8e42f57ad70e9f90382">&#9670;&nbsp;</a></span>integral_verify_test_exact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral_verify_test_exact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_exact_type&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; N &gt;::cb_type&#160;</td>
          <td class="paramname"><em>cb_arb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test contracted integrals in exact double precision. </p>
<p>The integrals are tested to be exactly equal to the reference data or to integral computed with very large accuracy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of centers the integral needs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals in exact double precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arb</td><td>Function that computes contracted integrals using interval arithmetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="aff8dfc46870c2a1ed84dc516fe2de727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8dfc46870c2a1ed84dc516fe2de727">&#9670;&nbsp;</a></span>integral_verify_test_exact< 4 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template long <a class="el" href="namespacemirp.html#ade8084713e84c8e42f57ad70e9f90382">mirp::integral_verify_test_exact</a>&lt; 4 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_exact_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmirp_1_1callback__helper.html">callback_helper</a>&lt; 4 &gt;::cb_type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7ec7b283a1a72f007fdc0b0ded9377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ec7b283a1a72f007fdc0b0ded9377b">&#9670;&nbsp;</a></span>nintegrals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t mirp::nintegrals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of integrals computed in an entry. </p>

</div>
</div>
<a id="a201a668b0bb583e336bbf6c87736435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201a668b0bb583e336bbf6c87736435e">&#9670;&nbsp;</a></span>print_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::print_results </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nfailed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ntests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the results of a test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfailed</td><td>Number of failed tests </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntests</td><td>Total number of tests run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdae67e044b4ee1c9b7a02614b093354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdae67e044b4ee1c9b7a02614b093354">&#9670;&nbsp;</a></span>read_construct_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; mirp::read_construct_basis </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xyzfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>basfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a basis from an XYZ file and a basis set file. </p>
<p>Create a basis from an XYZ file and a basis set file.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem reading or parsing the files</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyzfile</td><td>Path to a file containing atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basfile</td><td>Path to an NWChem-formatted basis set file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of shells obtained from applying the basis to the coordinate file</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem reading or parsing the files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af08924503706850419e98bf66456e4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08924503706850419e98bf66456e4b0">&#9670;&nbsp;</a></span>read_hexdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mirp::read_hexdouble </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double precision number from an ASCII file. </p>
<p>The main purpose of this is to convert hexfloat to doubles, since it seems streams can't read hexfloat</p>
<p>One double is extracted, and the stream advanced </p>

</div>
</div>
<a id="aa0d752a48c62a30d4f85481447e1f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d752a48c62a30d4f85481447e1f26c">&#9670;&nbsp;</a></span>reffile_read_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; mirp::reffile_read_basis </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads basis information from a reference file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>The file stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shells contained in the basis in the file </dd></dl>

</div>
</div>
<a id="a567695318a1326281c228be5413808e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567695318a1326281c228be5413808e8">&#9670;&nbsp;</a></span>reffile_write_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::reffile_write_basis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write basis information to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shells</td><td>The basis information to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Stream to write the information to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8b5ea8d0bc6fa4f54709a20c5660218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b5ea8d0bc6fa4f54709a20c5660218">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mirp::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into components. </p>
<p>The components must be separated by the character <code>sep</code> </p>

</div>
</div>
<a id="a8e024610a0f24170e0c7dfde2bfd195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e024610a0f24170e0c7dfde2bfd195c">&#9670;&nbsp;</a></span>str_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::str_tolower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to lower case, returning a copy. </p>

</div>
</div>
<a id="a0593df7c82e1f3e922aebfca8f2ac44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0593df7c82e1f3e922aebfca8f2ac44b">&#9670;&nbsp;</a></span>testfile_read_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a> mirp::testfile_read_integral </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read generic contracted integral test data from a file. </p>
<p>If <code>is_input</code> is set to true, then the returned data does not have the integral_data_entry::integral member populated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of centers in the integral (2 center, 4 center, etc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>True if the file is a test input file, false if it is a data file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the file </dd></dl>

</div>
</div>
<a id="ac9cfb997ce9f6b9062606aa5fb1bc440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cfb997ce9f6b9062606aa5fb1bc440">&#9670;&nbsp;</a></span>testfile_read_integral_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> mirp::testfile_read_integral_single </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read generic single integral test data from a file. </p>
<p>If <code>is_input</code> is set to true, then the returned data does not have the <a class="el" href="structmirp_1_1integral__single__data__entry.html#a5783273695c297bcd1c0dea144f57289" title="Actual data (integral) for this gaussian. ">integral_single_data_entry::integral</a> member populated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of centers in the integral (2 center, 4 center, etc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>True if the file is a test input file, false if it is a data file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the file </dd></dl>

</div>
</div>
<a id="ac5a6837ba61cdeb32f0fd40a61b2b351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a6837ba61cdeb32f0fd40a61b2b351">&#9670;&nbsp;</a></span>testfile_write_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::testfile_write_integral </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__data.html">integral_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write generic contracted integral test data to a file. </p>
<p>Any existing file at <code>filepath</code> will be overwritten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1968d0c11645895c1a3c03a47691db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1968d0c11645895c1a3c03a47691db0">&#9670;&nbsp;</a></span>testfile_write_integral_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::testfile_write_integral_single </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write generic single integral test data to a file. </p>
<p>Any existing file at <code>filepath</code> will be overwritten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfa167f623301da5e48af3af24931eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa167f623301da5e48af3af24931eb1">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims spaces and tabs from both ends of a string, returning a copy. </p>

</div>
</div>
<a id="a05562936e5f14fff46fa179684b71fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05562936e5f14fff46fa179684b71fdd">&#9670;&nbsp;</a></span>write_hexdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::write_hexdouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a double precision number as a hexfloat to an ASCII file. </p>
<p>The main purpose of this is to convert doubles to hexfloat, due to some standard libraries not supporting std::hexfloat</p>
<p>One double is written, and the stream advanced </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a33de878bfad803d7a1d02be008e1df75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de878bfad803d7a1d02be008e1df75">&#9670;&nbsp;</a></span>max_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::streamsize mirp::max_length = std::numeric_limits&lt;std::streamsize&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum length of a line. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 12 2018 13:57:11 for MolSSI Integral Reference Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
