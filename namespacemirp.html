<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MolSSI Integral Reference Project: mirp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="mirp_logo_477x219.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MolSSI Integral Reference Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mirp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of data for testing the Boys function.  <a href="structmirp_1_1boys__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1boys__data__entry.html">boys_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An single entry for a Boys function test.  <a href="structmirp_1_1boys__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shell of cartesian gaussian functions (double precision)  <a href="structmirp_1_1gaussian__shell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__shell__str.html">gaussian_shell_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shell of cartesian gaussian functions (strings)  <a href="structmirp_1_1gaussian__shell__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1gaussian__single__str.html">gaussian_single_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single cartesian gaussian function.  <a href="structmirp_1_1gaussian__single__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of a data file for contracted integrals.  <a href="structmirp_1_1integral__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for a single contracted integral.  <a href="structmirp_1_1integral__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of a data file for a single cartesian integral.  <a href="structmirp_1_1integral__single__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmirp_1_1integral__single__data__entry.html">integral_single_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for a single cartesian integral.  <a href="structmirp_1_1integral__single__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada07f7317a5c464516b637ff2ea73581"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ada07f7317a5c464516b637ff2ea73581">cmdline_has_arg</a> (const std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:ada07f7317a5c464516b637ff2ea73581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the given command line has an argument.  <a href="#ada07f7317a5c464516b637ff2ea73581">More...</a><br /></td></tr>
<tr class="separator:ada07f7317a5c464516b637ff2ea73581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1667b1a3866f9d460c474251c1bf471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a1667b1a3866f9d460c474251c1bf471f">cmdline_get_switch</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a1667b1a3866f9d460c474251c1bf471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the command line has a switch.  <a href="#a1667b1a3866f9d460c474251c1bf471f">More...</a><br /></td></tr>
<tr class="separator:a1667b1a3866f9d460c474251c1bf471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958486b749ea0de3331bbc2256574343"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a958486b749ea0de3331bbc2256574343">cmdline_get_arg_str</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a958486b749ea0de3331bbc2256574343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a string.  <a href="#a958486b749ea0de3331bbc2256574343">More...</a><br /></td></tr>
<tr class="separator:a958486b749ea0de3331bbc2256574343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c68eccff37c596fcd49b3a234649e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ad8c68eccff37c596fcd49b3a234649e6">cmdline_get_arg_str</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg, const std::string &amp;def)</td></tr>
<tr class="memdesc:ad8c68eccff37c596fcd49b3a234649e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a string, with a default.  <a href="#ad8c68eccff37c596fcd49b3a234649e6">More...</a><br /></td></tr>
<tr class="separator:ad8c68eccff37c596fcd49b3a234649e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c5d6bc1620517cb1dd3038139b222e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a14c5d6bc1620517cb1dd3038139b222e">cmdline_get_arg_long</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg)</td></tr>
<tr class="memdesc:a14c5d6bc1620517cb1dd3038139b222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a long integer.  <a href="#a14c5d6bc1620517cb1dd3038139b222e">More...</a><br /></td></tr>
<tr class="separator:a14c5d6bc1620517cb1dd3038139b222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a5339c262fa33a0e966f09c39d9e3c7b8">cmdline_get_arg_long</a> (std::vector&lt; std::string &gt; &amp;cmdline, const std::string &amp;arg, long def)</td></tr>
<tr class="memdesc:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of an argument from the command line as a long integer, with a default.  <a href="#a5339c262fa33a0e966f09c39d9e3c7b8">More...</a><br /></td></tr>
<tr class="separator:a5339c262fa33a0e966f09c39d9e3c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a5d1e9d32611a0f001ff3af9cf821ec33">convert_cmdline</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the command line passed to a program into a vector of strings.  <a href="#a5d1e9d32611a0f001ff3af9cf821ec33">More...</a><br /></td></tr>
<tr class="separator:a5d1e9d32611a0f001ff3af9cf821ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdae67e044b4ee1c9b7a02614b093354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#acdae67e044b4ee1c9b7a02614b093354">read_construct_basis</a> (const std::string &amp;xyzfile, const std::string &amp;basfile)</td></tr>
<tr class="memdesc:acdae67e044b4ee1c9b7a02614b093354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a basis from an XYZ file and a basis set file.  <a href="#acdae67e044b4ee1c9b7a02614b093354">More...</a><br /></td></tr>
<tr class="separator:acdae67e044b4ee1c9b7a02614b093354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d45a24f2eb91eb68273778e8139bbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a7d45a24f2eb91eb68273778e8139bbfa">integral4_create_reference</a> (const std::string &amp;xyz_filepath, const std::string &amp;basis_filepath, const std::string &amp;output_filepath, const std::string &amp;header, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;amlist, <a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a> cb)</td></tr>
<tr class="memdesc:a7d45a24f2eb91eb68273778e8139bbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a file with exact double reference values of contracted integrals.  <a href="#a7d45a24f2eb91eb68273778e8139bbfa">More...</a><br /></td></tr>
<tr class="separator:a7d45a24f2eb91eb68273778e8139bbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4de5ef1f0a14182ca593a8f68ca2c0c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ad4de5ef1f0a14182ca593a8f68ca2c0c">integral4_test_reference</a> (const std::string &amp;ref_filepath, <a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a> cb)</td></tr>
<tr class="memdesc:ad4de5ef1f0a14182ca593a8f68ca2c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests a reference file for consistency.  <a href="#ad4de5ef1f0a14182ca593a8f68ca2c0c">More...</a><br /></td></tr>
<tr class="separator:ad4de5ef1f0a14182ca593a8f68ca2c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08924503706850419e98bf66456e4b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#af08924503706850419e98bf66456e4b0">read_hexdouble</a> (std::istream &amp;fs)</td></tr>
<tr class="memdesc:af08924503706850419e98bf66456e4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double precision number from an ASCII file.  <a href="#af08924503706850419e98bf66456e4b0">More...</a><br /></td></tr>
<tr class="separator:af08924503706850419e98bf66456e4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05562936e5f14fff46fa179684b71fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a05562936e5f14fff46fa179684b71fdd">write_hexdouble</a> (double d, std::ostream &amp;fs)</td></tr>
<tr class="memdesc:a05562936e5f14fff46fa179684b71fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a double precision number as a hexfloat to an ASCII file.  <a href="#a05562936e5f14fff46fa179684b71fdd">More...</a><br /></td></tr>
<tr class="separator:a05562936e5f14fff46fa179684b71fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567695318a1326281c228be5413808e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a567695318a1326281c228be5413808e8">reffile_write_basis</a> (const std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; &amp;shells, std::ostream &amp;fs)</td></tr>
<tr class="memdesc:a567695318a1326281c228be5413808e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write basis information to a file.  <a href="#a567695318a1326281c228be5413808e8">More...</a><br /></td></tr>
<tr class="separator:a567695318a1326281c228be5413808e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d752a48c62a30d4f85481447e1f26c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa0d752a48c62a30d4f85481447e1f26c">reffile_read_basis</a> (std::istream &amp;fs)</td></tr>
<tr class="memdesc:aa0d752a48c62a30d4f85481447e1f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads basis information from a reference file.  <a href="#aa0d752a48c62a30d4f85481447e1f26c">More...</a><br /></td></tr>
<tr class="separator:aa0d752a48c62a30d4f85481447e1f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68880a28986479f968df96e21e54f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#af68880a28986479f968df96e21e54f05">boys_max_m</a> (const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;data)</td></tr>
<tr class="memdesc:af68880a28986479f968df96e21e54f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum value of <code>m</code> in a Boys test data structure.  <a href="#af68880a28986479f968df96e21e54f05">More...</a><br /></td></tr>
<tr class="separator:af68880a28986479f968df96e21e54f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab311bddb0cf68d4424b2ee430d817b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a2ab311bddb0cf68d4424b2ee430d817b">boys_read_file</a> (const std::string &amp;filepath, bool is_input)</td></tr>
<tr class="memdesc:a2ab311bddb0cf68d4424b2ee430d817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file with reference data for the Boys function.  <a href="#a2ab311bddb0cf68d4424b2ee430d817b">More...</a><br /></td></tr>
<tr class="separator:a2ab311bddb0cf68d4424b2ee430d817b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bc3e121f04df0e0a21551194ae3cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a24bc3e121f04df0e0a21551194ae3cb8">boys_write_file</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;data)</td></tr>
<tr class="memdesc:a24bc3e121f04df0e0a21551194ae3cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a file with reference data for the Boys function.  <a href="#a24bc3e121f04df0e0a21551194ae3cb8">More...</a><br /></td></tr>
<tr class="separator:a24bc3e121f04df0e0a21551194ae3cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541924126eaa8e44e802e756361f9747"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a541924126eaa8e44e802e756361f9747">boys_verify_test_main</a> (const std::string &amp;filepath, const std::string &amp;floattype, int extra_m, slong working_prec)</td></tr>
<tr class="memdesc:a541924126eaa8e44e802e756361f9747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a test of the Boys function.  <a href="#a541924126eaa8e44e802e756361f9747">More...</a><br /></td></tr>
<tr class="separator:a541924126eaa8e44e802e756361f9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#afe4f94b598ebbd2f92a358bdbfbc3361">boys_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header)</td></tr>
<tr class="memdesc:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a test file for the Boys function from a given input file.  <a href="#afe4f94b598ebbd2f92a358bdbfbc3361">More...</a><br /></td></tr>
<tr class="separator:afe4f94b598ebbd2f92a358bdbfbc3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fee805572ff9cb1eff7582169f0f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a41fee805572ff9cb1eff7582169f0f7f">almost_equal</a> (double a, double b, double tol)</td></tr>
<tr class="memdesc:a41fee805572ff9cb1eff7582169f0f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two double-precision numbers for equality within a tolerance.  <a href="#a41fee805572ff9cb1eff7582169f0f7f">More...</a><br /></td></tr>
<tr class="separator:a41fee805572ff9cb1eff7582169f0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a668b0bb583e336bbf6c87736435e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a201a668b0bb583e336bbf6c87736435e">print_results</a> (unsigned long nfailed, unsigned long ntests)</td></tr>
<tr class="memdesc:a201a668b0bb583e336bbf6c87736435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the results of a test.  <a href="#a201a668b0bb583e336bbf6c87736435e">More...</a><br /></td></tr>
<tr class="separator:a201a668b0bb583e336bbf6c87736435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c928248b24b1578f893e0680abaaab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a04c928248b24b1578f893e0680abaaab">amchar_to_int</a> (char am)</td></tr>
<tr class="memdesc:a04c928248b24b1578f893e0680abaaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a character representing an angular momentum to an integer.  <a href="#a04c928248b24b1578f893e0680abaaab">More...</a><br /></td></tr>
<tr class="separator:a04c928248b24b1578f893e0680abaaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49d727a23ba27fe18fc59b1a1af81f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#acf49d727a23ba27fe18fc59b1a1af81f">element_to_z</a> (const std::string &amp;element)</td></tr>
<tr class="memdesc:acf49d727a23ba27fe18fc59b1a1af81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representing an element to its atomic Z number.  <a href="#acf49d727a23ba27fe18fc59b1a1af81f">More...</a><br /></td></tr>
<tr class="separator:acf49d727a23ba27fe18fc59b1a1af81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e024610a0f24170e0c7dfde2bfd195c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a8e024610a0f24170e0c7dfde2bfd195c">str_tolower</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8e024610a0f24170e0c7dfde2bfd195c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to lower case, returning a copy.  <a href="#a8e024610a0f24170e0c7dfde2bfd195c">More...</a><br /></td></tr>
<tr class="separator:a8e024610a0f24170e0c7dfde2bfd195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa167f623301da5e48af3af24931eb1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#abfa167f623301da5e48af3af24931eb1">trim</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abfa167f623301da5e48af3af24931eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims spaces and tabs from both ends of a string, returning a copy.  <a href="#abfa167f623301da5e48af3af24931eb1">More...</a><br /></td></tr>
<tr class="separator:abfa167f623301da5e48af3af24931eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac8b5ea8d0bc6fa4f54709a20c5660218">split</a> (const std::string &amp;s, char sep=' ')</td></tr>
<tr class="memdesc:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into components.  <a href="#ac8b5ea8d0bc6fa4f54709a20c5660218">More...</a><br /></td></tr>
<tr class="separator:ac8b5ea8d0bc6fa4f54709a20c5660218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74abfb9a562297e55fb9e47a01e72ec0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a74abfb9a562297e55fb9e47a01e72ec0">file_skip</a> (std::istream &amp;fs, char commentchar)</td></tr>
<tr class="memdesc:a74abfb9a562297e55fb9e47a01e72ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the stream past any comment and blank lines.  <a href="#a74abfb9a562297e55fb9e47a01e72ec0">More...</a><br /></td></tr>
<tr class="separator:a74abfb9a562297e55fb9e47a01e72ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac7ec7b283a1a72f007fdc0b0ded9377b">nintegrals</a> (const <a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a> &amp;ent)</td></tr>
<tr class="memdesc:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of integrals computed in an entry.  <a href="#ac7ec7b283a1a72f007fdc0b0ded9377b">More...</a><br /></td></tr>
<tr class="separator:ac7ec7b283a1a72f007fdc0b0ded9377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74d132e83d2ddcb3a14dc4c84d1577d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#af74d132e83d2ddcb3a14dc4c84d1577d">integral4_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header, <a class="el" href="typedefs_8h.html#a1c16a1a39c3f93f8c0d1579f92d1a265">cb_integral4_str</a> cb)</td></tr>
<tr class="memdesc:af74d132e83d2ddcb3a14dc4c84d1577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test of contracted integrals.  <a href="#af74d132e83d2ddcb3a14dc4c84d1577d">More...</a><br /></td></tr>
<tr class="separator:af74d132e83d2ddcb3a14dc4c84d1577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c7024fff4ddc1baa3796aa7ec9884"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a238c7024fff4ddc1baa3796aa7ec9884">integral4_verify_test</a> (const std::string &amp;filepath, slong working_prec, <a class="el" href="typedefs_8h.html#a1c16a1a39c3f93f8c0d1579f92d1a265">cb_integral4_str</a> cb)</td></tr>
<tr class="memdesc:a238c7024fff4ddc1baa3796aa7ec9884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a test of single cartesian integrals.  <a href="#a238c7024fff4ddc1baa3796aa7ec9884">More...</a><br /></td></tr>
<tr class="separator:a238c7024fff4ddc1baa3796aa7ec9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff12c35cbda40778e7d6384484bd0952"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aff12c35cbda40778e7d6384484bd0952">integral4_verify_test_d</a> (const std::string &amp;filepath, <a class="el" href="typedefs_8h.html#ad48a6422cdf88c5e2404e7754a410ad6">cb_integral4_d</a> cb)</td></tr>
<tr class="memdesc:aff12c35cbda40778e7d6384484bd0952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test contracted integrals in double precision.  <a href="#aff12c35cbda40778e7d6384484bd0952">More...</a><br /></td></tr>
<tr class="separator:aff12c35cbda40778e7d6384484bd0952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ca01fb6ea01f646875ee97351cdfaf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ad5ca01fb6ea01f646875ee97351cdfaf">integral4_verify_test_exact</a> (const std::string &amp;filepath, <a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a> cb, <a class="el" href="typedefs_8h.html#a649ffd4b235bfb92f735edf0dc2bb7a4">cb_integral4</a> cb_mp)</td></tr>
<tr class="memdesc:ad5ca01fb6ea01f646875ee97351cdfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test contracted integrals in exact double precision.  <a href="#ad5ca01fb6ea01f646875ee97351cdfaf">More...</a><br /></td></tr>
<tr class="separator:ad5ca01fb6ea01f646875ee97351cdfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf20a4cfd122b51e8d60303eec407cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aaf20a4cfd122b51e8d60303eec407cd2">integral4_single_create_test</a> (const std::string &amp;input_filepath, const std::string &amp;output_filepath, slong working_prec, long ndigits, const std::string &amp;header, <a class="el" href="typedefs_8h.html#ae6c0106acd451647025e1c96ba29b22d">cb_integral4_single_str</a> cb)</td></tr>
<tr class="memdesc:aaf20a4cfd122b51e8d60303eec407cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test of single cartesian integrals.  <a href="#aaf20a4cfd122b51e8d60303eec407cd2">More...</a><br /></td></tr>
<tr class="separator:aaf20a4cfd122b51e8d60303eec407cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809e54f17585b9d91d860414005c6686"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a809e54f17585b9d91d860414005c6686">integral4_single_verify_test</a> (const std::string &amp;filepath, slong working_prec, <a class="el" href="typedefs_8h.html#ae6c0106acd451647025e1c96ba29b22d">cb_integral4_single_str</a> cb)</td></tr>
<tr class="memdesc:a809e54f17585b9d91d860414005c6686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a test of single cartesian integrals using interval math.  <a href="#a809e54f17585b9d91d860414005c6686">More...</a><br /></td></tr>
<tr class="separator:a809e54f17585b9d91d860414005c6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54f835c9d736cfb31f8289c5dad3b46"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa54f835c9d736cfb31f8289c5dad3b46">integral4_single_verify_test_d</a> (const std::string &amp;filepath, <a class="el" href="typedefs_8h.html#ab4bde9b22667586d502024f2a015ead3">cb_integral4_single_d</a> cb)</td></tr>
<tr class="memdesc:aa54f835c9d736cfb31f8289c5dad3b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test single cartesian integrals in double precision.  <a href="#aa54f835c9d736cfb31f8289c5dad3b46">More...</a><br /></td></tr>
<tr class="separator:aa54f835c9d736cfb31f8289c5dad3b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a67bd4338edbc7513b3495606b5bf2f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a8a67bd4338edbc7513b3495606b5bf2f">integral4_single_verify_test_exact</a> (const std::string &amp;filepath, <a class="el" href="typedefs_8h.html#a55e29f3bdeaac872f8b9986c0715466f">cb_integral4_single_exact</a> cb, <a class="el" href="typedefs_8h.html#a417fa18f7fa2d551142a35b4d24d8747">cb_integral4_single</a> cb_mp)</td></tr>
<tr class="memdesc:a8a67bd4338edbc7513b3495606b5bf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test single cartesian integrals in exact double precision.  <a href="#a8a67bd4338edbc7513b3495606b5bf2f">More...</a><br /></td></tr>
<tr class="separator:a8a67bd4338edbc7513b3495606b5bf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac9cfb997ce9f6b9062606aa5fb1bc440">testfile_read_integral_single</a> (const std::string &amp;filepath, int n, bool is_input)</td></tr>
<tr class="memdesc:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read generic single integral test data from a file.  <a href="#ac9cfb997ce9f6b9062606aa5fb1bc440">More...</a><br /></td></tr>
<tr class="separator:ac9cfb997ce9f6b9062606aa5fb1bc440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1968d0c11645895c1a3c03a47691db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#aa1968d0c11645895c1a3c03a47691db0">testfile_write_integral_single</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> &amp;data)</td></tr>
<tr class="memdesc:aa1968d0c11645895c1a3c03a47691db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write generic single integral test data to a file.  <a href="#aa1968d0c11645895c1a3c03a47691db0">More...</a><br /></td></tr>
<tr class="separator:aa1968d0c11645895c1a3c03a47691db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a0593df7c82e1f3e922aebfca8f2ac44b">testfile_read_integral</a> (const std::string &amp;filepath, int n, bool is_input)</td></tr>
<tr class="memdesc:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read generic contracted integral test data from a file.  <a href="#a0593df7c82e1f3e922aebfca8f2ac44b">More...</a><br /></td></tr>
<tr class="separator:a0593df7c82e1f3e922aebfca8f2ac44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#ac5a6837ba61cdeb32f0fd40a61b2b351">testfile_write_integral</a> (const std::string &amp;filepath, const <a class="el" href="structmirp_1_1integral__data.html">integral_data</a> &amp;data)</td></tr>
<tr class="memdesc:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write generic contracted integral test data to a file.  <a href="#ac5a6837ba61cdeb32f0fd40a61b2b351">More...</a><br /></td></tr>
<tr class="separator:ac5a6837ba61cdeb32f0fd40a61b2b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a33de878bfad803d7a1d02be008e1df75"><td class="memItemLeft" align="right" valign="top">static const std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemirp.html#a33de878bfad803d7a1d02be008e1df75">max_length</a> = std::numeric_limits&lt;std::streamsize&gt;::max()</td></tr>
<tr class="separator:a33de878bfad803d7a1d02be008e1df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace for MIRP in C++ </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a41fee805572ff9cb1eff7582169f0f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fee805572ff9cb1eff7582169f0f7f">&#9670;&nbsp;</a></span>almost_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two double-precision numbers for equality within a tolerance. </p>
<p>This tests the relative difference between two double-precision values.</p>
<p>The relative difference is calculated as</p>
<p>abs(a - b)/max(abs(a), abs(b))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>Values to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Tolerance to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the relative difference is less than <code>tol</code> </dd></dl>

</div>
</div>
<a id="a04c928248b24b1578f893e0680abaaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c928248b24b1578f893e0680abaaab">&#9670;&nbsp;</a></span>amchar_to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::amchar_to_int </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>am</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a character representing an angular momentum to an integer. </p>
<p>Converts s,p,d,f,... to 0,1,2,3,...</p>
<p>The character is case insensitive</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the character cannot be converted to an integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe4f94b598ebbd2f92a358bdbfbc3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4f94b598ebbd2f92a358bdbfbc3361">&#9670;&nbsp;</a></span>boys_create_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::boys_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a test file for the Boys function from a given input file. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>Path to the input file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>File to write the computed data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of decimal digits to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Any descriptive header data (will be appended to the existing header in the input file) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af68880a28986479f968df96e21e54f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68880a28986479f968df96e21e54f05">&#9670;&nbsp;</a></span>boys_max_m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::boys_max_m </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum value of <code>m</code> in a Boys test data structure. </p>

</div>
</div>
<a id="a2ab311bddb0cf68d4424b2ee430d817b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab311bddb0cf68d4424b2ee430d817b">&#9670;&nbsp;</a></span>boys_read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1boys__data.html">boys_data</a> mirp::boys_read_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a file with reference data for the Boys function. </p>
<p>This reads in <code>m</code> and <code>t</code> entries for the Boys function, as well as a descriptive header.</p>
<p>If <code>is_input</code> is true, then then <code>ndigits</code> and the reference entries are also read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file does not exist or there there is a problem reading/parsing the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>Set to true when reading an input file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data in the file </dd></dl>

</div>
</div>
<a id="a541924126eaa8e44e802e756361f9747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541924126eaa8e44e802e756361f9747">&#9670;&nbsp;</a></span>boys_verify_test_main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::boys_verify_test_main </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>floattype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a test of the Boys function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floattype</td><td>Type of floating point to test ("double", for example) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra_m</td><td>Additional <code>m</code> entries (used to test recurrence relations) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of tests that have failed </dd></dl>

</div>
</div>
<a id="a24bc3e121f04df0e0a21551194ae3cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bc3e121f04df0e0a21551194ae3cb8">&#9670;&nbsp;</a></span>boys_write_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::boys_write_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1boys__data.html">boys_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a file with reference data for the Boys function. </p>
<p>This writes reference data files only. It can not be used to write input files.</p>
<p>Any existing file will be overrwitten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c5d6bc1620517cb1dd3038139b222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c5d6bc1620517cb1dd3038139b222e">&#9670;&nbsp;</a></span>cmdline_get_arg_long() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::cmdline_get_arg_long </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a long integer. </p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the argument key or the value is not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line </dd></dl>

</div>
</div>
<a id="a5339c262fa33a0e966f09c39d9e3c7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5339c262fa33a0e966f09c39d9e3c7b8">&#9670;&nbsp;</a></span>cmdline_get_arg_long() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::cmdline_get_arg_long </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a long integer, with a default. </p>
<p>If the argument key is not given on the command line, the default parameter <code>def</code> is returned instead.</p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>A default value of the argument to use if <code>arg</code> is not given on the command line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line, or the value of <code>def</code> </dd></dl>

</div>
</div>
<a id="a958486b749ea0de3331bbc2256574343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958486b749ea0de3331bbc2256574343">&#9670;&nbsp;</a></span>cmdline_get_arg_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::cmdline_get_arg_str </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a string. </p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the argument key or the value is not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line </dd></dl>

</div>
</div>
<a id="ad8c68eccff37c596fcd49b3a234649e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c68eccff37c596fcd49b3a234649e6">&#9670;&nbsp;</a></span>cmdline_get_arg_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::cmdline_get_arg_str </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the value of an argument from the command line as a string, with a default. </p>
<p>If the argument key is not given on the command line, the default parameter <code>def</code> is returned instead.</p>
<dl class="section note"><dt>Note</dt><dd>After obtaining the argument, the key and value are removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to use (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument key to look up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>A default value of the argument to use if <code>arg</code> is not given on the command line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the argument given on the command line, or the value of <code>def</code> </dd></dl>

</div>
</div>
<a id="a1667b1a3866f9d460c474251c1bf471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1667b1a3866f9d460c474251c1bf471f">&#9670;&nbsp;</a></span>cmdline_get_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::cmdline_get_switch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if the command line has a switch. </p>
<dl class="section note"><dt>Note</dt><dd>After seeing if the switch exists, it is removed from <code>cmdline</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to check (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>cmdline</code> contains the switch, false otherwise </dd></dl>

</div>
</div>
<a id="ada07f7317a5c464516b637ff2ea73581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada07f7317a5c464516b637ff2ea73581">&#9670;&nbsp;</a></span>cmdline_has_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::cmdline_has_arg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the given command line has an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>The command line to check (should be converted already) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>cmdline</code> contains the argument, false otherwise </dd></dl>

</div>
</div>
<a id="a5d1e9d32611a0f001ff3af9cf821ec33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1e9d32611a0f001ff3af9cf821ec33">&#9670;&nbsp;</a></span>convert_cmdline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mirp::convert_cmdline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the command line passed to a program into a vector of strings. </p>
<p>After conversion, the command line is able to be used in the other <code>cmdline_</code> functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command line arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>The command line arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The command line, split into a vector of strings and lightly processed. </dd></dl>

</div>
</div>
<a id="acf49d727a23ba27fe18fc59b1a1af81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49d727a23ba27fe18fc59b1a1af81f">&#9670;&nbsp;</a></span>element_to_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mirp::element_to_z </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string representing an element to its atomic Z number. </p>
<p>Converts H to 1, He to 2, etc</p>
<p>The element string is case insensitive</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the character cannot be converted to an integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74abfb9a562297e55fb9e47a01e72ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74abfb9a562297e55fb9e47a01e72ec0">&#9670;&nbsp;</a></span>file_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mirp::file_skip </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>commentchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the stream past any comment and blank lines. </p>
<p>The stream will be advanced past the lines that were read.</p>
<p>If an EOF is encountered, false is returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>The stream to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commentchar</td><td>Lines beginning with the character will be skipped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is additional data in the file, false on EOF </dd></dl>

</div>
</div>
<a id="a7d45a24f2eb91eb68273778e8139bbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d45a24f2eb91eb68273778e8139bbfa">&#9670;&nbsp;</a></span>integral4_create_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral4_create_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xyz_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>basis_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>amlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a file with exact double reference values of contracted integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz_filepath</td><td>Path to the XYZ file containing the molecule to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basis_filepath</td><td>Path to a basis set file to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amlist</td><td>Vector of AM classes to compute. If empty, all will be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals to exact double precision </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af74d132e83d2ddcb3a14dc4c84d1577d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74d132e83d2ddcb3a14dc4c84d1577d">&#9670;&nbsp;</a></span>integral4_create_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral4_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a1c16a1a39c3f93f8c0d1579f92d1a265">cb_integral4_str</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test of contracted integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>The input file to use for integral parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of digits to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf20a4cfd122b51e8d60303eec407cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf20a4cfd122b51e8d60303eec407cd2">&#9670;&nbsp;</a></span>integral4_single_create_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::integral4_single_create_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ndigits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#ae6c0106acd451647025e1c96ba29b22d">cb_integral4_single_str</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test of single cartesian integrals. </p>
<p>Any existing output file (given by <code>output_filepath</code>) will be overwritten.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the working precision is not sufficient for the specified number of digits</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_filepath</td><td>The input file to use for integral parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_filepath</td><td>The output file to write the computed integrals to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndigits</td><td>Number of digits to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header information to add to the file (appended to the input file header) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a809e54f17585b9d91d860414005c6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809e54f17585b9d91d860414005c6686">&#9670;&nbsp;</a></span>integral4_single_verify_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_single_verify_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#ae6c0106acd451647025e1c96ba29b22d">cb_integral4_single_str</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a test of single cartesian integrals using interval math. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="aa54f835c9d736cfb31f8289c5dad3b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54f835c9d736cfb31f8289c5dad3b46">&#9670;&nbsp;</a></span>integral4_single_verify_test_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_single_verify_test_d </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#ab4bde9b22667586d502024f2a015ead3">cb_integral4_single_d</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test single cartesian integrals in double precision. </p>
<p>The integrals are tested to a lower relative accuracy to account for rounding error in the double-precision integral kernels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals in double precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="a8a67bd4338edbc7513b3495606b5bf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a67bd4338edbc7513b3495606b5bf2f">&#9670;&nbsp;</a></span>integral4_single_verify_test_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_single_verify_test_exact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a55e29f3bdeaac872f8b9986c0715466f">cb_integral4_single_exact</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a417fa18f7fa2d551142a35b4d24d8747">cb_integral4_single</a>&#160;</td>
          <td class="paramname"><em>cb_mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test single cartesian integrals in exact double precision. </p>
<p>The integrals are tested to be exactly equal to the reference data or to integral computed with very large accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes single cartesian integrals in exact double precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_mp</td><td>Function that computes single cartesian integrals using interval arithmetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="ad4de5ef1f0a14182ca593a8f68ca2c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4de5ef1f0a14182ca593a8f68ca2c0c">&#9670;&nbsp;</a></span>integral4_test_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_test_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ref_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests a reference file for consistency. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_filepath</td><td>Path to the reference file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals to exact double precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="a238c7024fff4ddc1baa3796aa7ec9884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238c7024fff4ddc1baa3796aa7ec9884">&#9670;&nbsp;</a></span>integral4_verify_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_verify_test </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slong&#160;</td>
          <td class="paramname"><em>working_prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a1c16a1a39c3f93f8c0d1579f92d1a265">cb_integral4_str</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a test of single cartesian integrals. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening the file or there there is a problem reading or writing the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">working_prec</td><td>Internal working precision to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="aff12c35cbda40778e7d6384484bd0952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff12c35cbda40778e7d6384484bd0952">&#9670;&nbsp;</a></span>integral4_verify_test_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_verify_test_d </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#ad48a6422cdf88c5e2404e7754a410ad6">cb_integral4_d</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test contracted integrals in double precision. </p>
<p>The integrals are tested to a lower relative accuracy to account for rounding error in the double-precision integral kernels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals in double precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="ad5ca01fb6ea01f646875ee97351cdfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ca01fb6ea01f646875ee97351cdfaf">&#9670;&nbsp;</a></span>integral4_verify_test_exact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long mirp::integral4_verify_test_exact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a068b7fddadc3a6e5102473c6b56ea41b">cb_integral4_exact</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8h.html#a649ffd4b235bfb92f735edf0dc2bb7a4">cb_integral4</a>&#160;</td>
          <td class="paramname"><em>cb_mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test contracted integrals in exact double precision. </p>
<p>The integrals are tested to be exactly equal to the reference data or to integral computed with very large accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file with the reference data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Function that computes contracted integrals in exact double precision </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_mp</td><td>Function that computes contracted integrals using interval arithmetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of failed tests </dd></dl>

</div>
</div>
<a id="ac7ec7b283a1a72f007fdc0b0ded9377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ec7b283a1a72f007fdc0b0ded9377b">&#9670;&nbsp;</a></span>nintegrals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t mirp::nintegrals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__data__entry.html">integral_data_entry</a> &amp;&#160;</td>
          <td class="paramname"><em>ent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of integrals computed in an entry. </p>

</div>
</div>
<a id="a201a668b0bb583e336bbf6c87736435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201a668b0bb583e336bbf6c87736435e">&#9670;&nbsp;</a></span>print_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::print_results </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nfailed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ntests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the results of a test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfailed</td><td>Number of failed tests </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntests</td><td>Total number of tests run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdae67e044b4ee1c9b7a02614b093354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdae67e044b4ee1c9b7a02614b093354">&#9670;&nbsp;</a></span>read_construct_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; mirp::read_construct_basis </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xyzfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>basfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a basis from an XYZ file and a basis set file. </p>
<p>Create a basis from an XYZ file and a basis set file.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem reading or parsing the files</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyzfile</td><td>Path to a file containing atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basfile</td><td>Path to an NWChem-formatted basis set file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of shells obtained from applying the basis to the coordinate file</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem reading or parsing the files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af08924503706850419e98bf66456e4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08924503706850419e98bf66456e4b0">&#9670;&nbsp;</a></span>read_hexdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mirp::read_hexdouble </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double precision number from an ASCII file. </p>
<p>The main purpose of this is to convert hexfloat to doubles, since it seems streams can't read hexfloat</p>
<p>One double is extracted, and the stream advanced </p>

</div>
</div>
<a id="aa0d752a48c62a30d4f85481447e1f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d752a48c62a30d4f85481447e1f26c">&#9670;&nbsp;</a></span>reffile_read_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; mirp::reffile_read_basis </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads basis information from a reference file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>The file stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shells contained in the basis in the file </dd></dl>

</div>
</div>
<a id="a567695318a1326281c228be5413808e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567695318a1326281c228be5413808e8">&#9670;&nbsp;</a></span>reffile_write_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::reffile_write_basis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmirp_1_1gaussian__shell.html">gaussian_shell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write basis information to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shells</td><td>The basis information to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Stream to write the information to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8b5ea8d0bc6fa4f54709a20c5660218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b5ea8d0bc6fa4f54709a20c5660218">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mirp::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a string into components. </p>
<p>The components must be separated by the character <code>sep</code> </p>

</div>
</div>
<a id="a8e024610a0f24170e0c7dfde2bfd195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e024610a0f24170e0c7dfde2bfd195c">&#9670;&nbsp;</a></span>str_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::str_tolower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to lower case, returning a copy. </p>

</div>
</div>
<a id="a0593df7c82e1f3e922aebfca8f2ac44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0593df7c82e1f3e922aebfca8f2ac44b">&#9670;&nbsp;</a></span>testfile_read_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1integral__data.html">integral_data</a> mirp::testfile_read_integral </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read generic contracted integral test data from a file. </p>
<p>If <code>is_input</code> is set to true, then the returned data does not have the integral_data_entry::integral member populated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of centers in the integral (2 center, 4 center, etc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>True if the file is a test input file, false if it is a data file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the file </dd></dl>

</div>
</div>
<a id="ac9cfb997ce9f6b9062606aa5fb1bc440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cfb997ce9f6b9062606aa5fb1bc440">&#9670;&nbsp;</a></span>testfile_read_integral_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> mirp::testfile_read_integral_single </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read generic single integral test data from a file. </p>
<p>If <code>is_input</code> is set to true, then the returned data does not have the <a class="el" href="structmirp_1_1integral__single__data__entry.html#a5783273695c297bcd1c0dea144f57289" title="Actual data (integral) for this gaussian. ">integral_single_data_entry::integral</a> member populated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of centers in the integral (2 center, 4 center, etc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_input</td><td>True if the file is a test input file, false if it is a data file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the file </dd></dl>

</div>
</div>
<a id="ac5a6837ba61cdeb32f0fd40a61b2b351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a6837ba61cdeb32f0fd40a61b2b351">&#9670;&nbsp;</a></span>testfile_write_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::testfile_write_integral </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__data.html">integral_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write generic contracted integral test data to a file. </p>
<p>Any existing file at <code>filepath</code> will be overwritten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1968d0c11645895c1a3c03a47691db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1968d0c11645895c1a3c03a47691db0">&#9670;&nbsp;</a></span>testfile_write_integral_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::testfile_write_integral_single </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmirp_1_1integral__single__data.html">integral_single_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write generic single integral test data to a file. </p>
<p>Any existing file at <code>filepath</code> will be overwritten</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a problem opening or writing to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfa167f623301da5e48af3af24931eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa167f623301da5e48af3af24931eb1">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mirp::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims spaces and tabs from both ends of a string, returning a copy. </p>

</div>
</div>
<a id="a05562936e5f14fff46fa179684b71fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05562936e5f14fff46fa179684b71fdd">&#9670;&nbsp;</a></span>write_hexdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mirp::write_hexdouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a double precision number as a hexfloat to an ASCII file. </p>
<p>The main purpose of this is to convert doubles to hexfloat, due to some standard libraries not supporting std::hexfloat</p>
<p>One double is written, and the stream advanced </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a33de878bfad803d7a1d02be008e1df75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de878bfad803d7a1d02be008e1df75">&#9670;&nbsp;</a></span>max_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::streamsize mirp::max_length = std::numeric_limits&lt;std::streamsize&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 30 2017 10:52:14 for MolSSI Integral Reference Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
